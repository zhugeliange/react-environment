/**
 *  Copyright (c) 2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _codemirror = require('codemirror');

var _codemirror2 = _interopRequireDefault(_codemirror);

var _graphql = require('graphql');

var _graphqlTypeIntrospection = require('graphql/type/introspection');

require('./mode');

/**
 * Registers a "hint" helper for CodeMirror.
 *
 * Using CodeMirror's "hint" addon: https://codemirror.net/demo/complete.html
 * Given an editor, this helper will take the token at the cursor and return a
 * list of suggested tokens.
 *
 * Options:
 *
 *   - schema: GraphQLSchema provides the hinter with positionally relevant info
 *
 * Additional Events:
 *
 *   - hasCompletion (codemirror, data, token) - signaled when the hinter has a
 *     new list of completion suggestions.
 *
 */
_codemirror2['default'].registerHelper('hint', 'graphql', function (editor, options) {
  var schema = options.schema;
  if (!schema) {
    return;
  }

  var cur = editor.getCursor();
  var token = editor.getTokenAt(cur);
  var typeInfo = getTypeInfo(schema, token.state);

  var state = token.state;
  var kind = state.kind;
  var step = state.step;

  if (token.type === 'comment') {
    return;
  }

  // Definition kinds
  if (kind === 'Document') {
    return hintList(editor, options, cur, token, [{ text: 'query' }, { text: 'mutation' }, { text: 'subscription' }, { text: 'fragment' }, { text: '{' }]);
  }

  // Field names
  if (kind === 'SelectionSet' || kind === 'Field' || kind === 'AliasedField') {
    if (typeInfo.parentType) {
      var fields;
      if (typeInfo.parentType.getFields) {
        var fieldObj = typeInfo.parentType.getFields();
        fields = Object.keys(fieldObj).map(function (fieldName) {
          return fieldObj[fieldName];
        });
      } else {
        fields = [];
      }
      if (_graphql.isAbstractType(typeInfo.parentType)) {
        fields.push(_graphqlTypeIntrospection.TypeNameMetaFieldDef);
      }
      if (typeInfo.parentType === schema.getQueryType()) {
        fields.push(_graphqlTypeIntrospection.SchemaMetaFieldDef, _graphqlTypeIntrospection.TypeMetaFieldDef);
      }
      return hintList(editor, options, cur, token, fields.map(function (field) {
        return {
          text: field.name,
          type: field.type,
          description: field.description
        };
      }));
    }
  }

  // Argument names
  if (kind === 'Arguments' || kind === 'Argument' && step === 0) {
    var argDefs = typeInfo.argDefs;
    if (argDefs) {
      return hintList(editor, options, cur, token, argDefs.map(function (argDef) {
        return {
          text: argDef.name,
          type: argDef.type,
          description: argDef.description
        };
      }));
    }
  }

  // Input Object fields
  if (kind === 'ObjectValue' || kind === 'ObjectField' && step === 0) {
    if (typeInfo.objectFieldDefs) {
      var objectFields = Object.keys(typeInfo.objectFieldDefs).map(function (fieldName) {
        return typeInfo.objectFieldDefs[fieldName];
      });
      return hintList(editor, options, cur, token, objectFields.map(function (field) {
        return {
          text: field.name,
          type: field.type,
          description: field.description
        };
      }));
    }
  }

  // Input values: Enum and Boolean
  if (kind === 'EnumValue' || kind === 'ListValue' && step === 1 || kind === 'ObjectField' && step === 2 || kind === 'Argument' && step === 2) {
    var namedInputType = _graphql.getNamedType(typeInfo.inputType);
    if (namedInputType instanceof _graphql.GraphQLEnumType) {
      var valueMap = namedInputType.getValues();
      var values = Object.keys(valueMap).map(function (valueName) {
        return valueMap[valueName];
      });
      return hintList(editor, options, cur, token, values.map(function (value) {
        return {
          text: value.name,
          type: namedInputType,
          description: value.description
        };
      }));
    } else if (namedInputType === _graphql.GraphQLBoolean) {
      return hintList(editor, options, cur, token, [{ text: 'true', type: _graphql.GraphQLBoolean, description: 'Not false.' }, { text: 'false', type: _graphql.GraphQLBoolean, description: 'Not true.' }]);
    }
  }

  // Fragment type conditions
  if (kind === 'TypeCondition' && step === 1 || kind === 'NamedType' && state.prevState.kind === 'TypeCondition') {
    var possibleTypes;
    if (typeInfo.parentType) {
      possibleTypes = _graphql.isAbstractType(typeInfo.parentType) ? typeInfo.parentType.getPossibleTypes() : [typeInfo.parentType];
    } else {
      (function () {
        var typeMap = schema.getTypeMap();
        possibleTypes = Object.keys(typeMap).map(function (typeName) {
          return typeMap[typeName];
        }).filter(_graphql.isCompositeType);
      })();
    }
    return hintList(editor, options, cur, token, possibleTypes.map(function (type) {
      return {
        text: type.name,
        description: type.description
      };
    }));
  }

  // Fragment spread names
  if (kind === 'FragmentSpread' && step === 1) {
    var _ret2 = (function () {
      var typeMap = schema.getTypeMap();
      var defState = getDefinitionState(token.state);
      var fragments = getFragmentDefinitions(editor);

      // Filter down to only the fragments which may exist here.
      var relevantFrags = fragments.filter(function (frag) {
        return(
          // Only include fragments with known types.
          typeMap[frag.typeCondition.name.value] &&
          // Only include fragments which are not cyclic.
          !(defState && defState.kind === 'FragmentDefinition' && defState.name === frag.name.value) &&
          // Only include fragments which could possibly be spread here.
          _graphql.doTypesOverlap(typeInfo.parentType, typeMap[frag.typeCondition.name.value])
        );
      });

      return {
        v: hintList(editor, options, cur, token, relevantFrags.map(function (frag) {
          return {
            text: frag.name.value,
            type: typeMap[frag.typeCondition.name.value],
            description: 'fragment ' + frag.name.value + ' on ' + frag.typeCondition.name.value
          };
        }))
      };
    })();

    if (typeof _ret2 === 'object') return _ret2.v;
  }

  // Variable definition types
  if (kind === 'VariableDefinition' && step === 2 || kind === 'ListType' && step === 1 || kind === 'NamedType' && (state.prevState.kind === 'VariableDefinition' || state.prevState.kind === 'ListType')) {
    var inputTypeMap = schema.getTypeMap();
    var inputTypes = Object.keys(inputTypeMap).map(function (typeName) {
      return inputTypeMap[typeName];
    }).filter(_graphql.isInputType);
    return hintList(editor, options, cur, token, inputTypes.map(function (type) {
      return {
        text: type.name,
        description: type.description
      };
    }));
  }

  // Directive names
  if (kind === 'Directive') {
    var directives = schema.getDirectives().filter(function (directive) {
      return directive.onField && state.prevState.kind === 'Field' || directive.onFragment && (state.prevState.kind === 'FragmentDefinition' || state.prevState.kind === 'InlineFragment' || state.prevState.kind === 'FragmentSpread') || directive.onOperation && (state.prevState.kind === 'Query' || state.prevState.kind === 'Mutation' || state.prevState.kind === 'Subscription');
    });
    return hintList(editor, options, cur, token, directives.map(function (directive) {
      return {
        text: directive.name,
        description: directive.description
      };
    }));
  }
});

// Utility for collecting rich type information given any token's state
// from the graphql-mode parser.
function getTypeInfo(schema, tokenState) {
  var info = {
    type: null,
    parentType: null,
    inputType: null,
    directiveDef: null,
    fieldDef: null,
    argDef: null,
    argDefs: null,
    objectFieldDefs: null
  };

  forEachState(tokenState, function (state) {
    switch (state.kind) {
      case 'Query':
      case 'ShortQuery':
        info.type = schema.getQueryType();
        break;
      case 'Mutation':
        info.type = schema.getMutationType();
        break;
      case 'Subscription':
        info.type = schema.getSubscriptionType();
        break;
      case 'InlineFragment':
      case 'FragmentDefinition':
        if (state.type) {
          info.type = schema.getType(state.type);
        }
        break;
      case 'Field':
        info.fieldDef = info.type && state.name ? getFieldDef(schema, info.parentType, state.name) : null;
        info.type = info.fieldDef && info.fieldDef.type;
        break;
      case 'SelectionSet':
        info.parentType = _graphql.getNamedType(info.type);
        break;
      case 'Directive':
        info.directiveDef = state.name && schema.getDirective(state.name);
        break;
      case 'Arguments':
        info.argDefs = state.prevState.kind === 'Field' ? info.fieldDef && info.fieldDef.args : state.prevState.kind === 'Directive' ? info.directiveDef && info.directiveDef.args : null;
        break;
      case 'Argument':
        info.argDef = null;
        if (info.argDefs) {
          for (var i = 0; i < info.argDefs.length; i++) {
            if (info.argDefs[i].name === state.name) {
              info.argDef = info.argDefs[i];
              break;
            }
          }
        }
        info.inputType = info.argDef && info.argDef.type;
        break;
      case 'ListValue':
        var nullableType = _graphql.getNullableType(info.inputType);
        info.inputType = nullableType instanceof _graphql.GraphQLList ? nullableType.ofType : null;
        break;
      case 'ObjectValue':
        var objectType = _graphql.getNamedType(info.inputType);
        info.objectFieldDefs = objectType instanceof _graphql.GraphQLInputObjectType ? objectType.getFields() : null;
        break;
      case 'ObjectField':
        var objectField = state.name && info.objectFieldDefs ? info.objectFieldDefs[state.name] : null;
        info.inputType = objectField && objectField.type;
        break;
    }
  });

  return info;
}

// Utility for returning the state representing the Definition this token state
// is within, if any.
function getDefinitionState(tokenState) {
  var definitionState = undefined;

  forEachState(tokenState, function (state) {
    switch (state.kind) {
      case 'Query':
      case 'ShortQuery':
      case 'Mutation':
      case 'Subscription':
      case 'FragmentDefinition':
        definitionState = state;
        break;
    }
  });

  return definitionState;
}

// Utility for iterating through a state stack bottom-up.
function forEachState(stack, fn) {
  var reverseStateStack = [];
  var state = stack;
  while (state && state.kind) {
    reverseStateStack.push(state);
    state = state.prevState;
  }
  for (var i = reverseStateStack.length - 1; i >= 0; i--) {
    fn(reverseStateStack[i]);
  }
}

// Finds all fragment definition ASTs in a source.
function getFragmentDefinitions(editor) {
  var fragmentDefs = [];
  runMode(editor, 'graphql', function (state) {
    if (state.kind === 'FragmentDefinition' && state.name && state.type) {
      fragmentDefs.push({
        kind: 'FragmentDefinition',
        name: {
          kind: 'Name',
          value: state.name
        },
        typeCondition: {
          kind: 'NamedType',
          name: {
            kind: 'Name',
            value: state.type
          }
        }
      });
    }
  });
  return fragmentDefs;
}

// Utility for efficiently running a codemirror mode over an editor's current
// state, calling an iterFn function on each token.
function runMode(editor, modeSpec, iterFn) {
  var mode = _codemirror2['default'].getMode(_codemirror2['default'].defaults, modeSpec);
  var state = _codemirror2['default'].startState(mode);
  editor.eachLine(function (line) {
    var stream = new _codemirror2['default'].StringStream(line.text);
    while (!stream.eol()) {
      var style = mode.token(stream, state);
      iterFn(state, style, stream);
      stream.start = stream.pos;
    }
  });
}

// Gets the field definition given a type and field name
function getFieldDef(schema, type, fieldName) {
  if (fieldName === _graphqlTypeIntrospection.SchemaMetaFieldDef.name && schema.getQueryType() === type) {
    return _graphqlTypeIntrospection.SchemaMetaFieldDef;
  }
  if (fieldName === _graphqlTypeIntrospection.TypeMetaFieldDef.name && schema.getQueryType() === type) {
    return _graphqlTypeIntrospection.TypeMetaFieldDef;
  }
  if (fieldName === _graphqlTypeIntrospection.TypeNameMetaFieldDef.name && _graphql.isCompositeType(type)) {
    return _graphqlTypeIntrospection.TypeNameMetaFieldDef;
  }
  if (type.getFields) {
    return type.getFields()[fieldName];
  }
}

// Create the expected hint response given a possible list and a token
function hintList(editor, options, cursor, token, list) {
  var hints = filterAndSortList(list, normalizeText(token.string));
  if (!hints) {
    return;
  }

  var tokenStart = token.type !== null && /\w/.test(token.string[0]) ? token.start : token.end;

  var results = {
    list: hints,
    from: _codemirror2['default'].Pos(cursor.line, tokenStart),
    to: _codemirror2['default'].Pos(cursor.line, token.end)
  };

  _codemirror2['default'].signal(editor, 'hasCompletion', editor, results, token);

  return results;
}

// Given a list of hint entries and currently typed text, sort and filter to
// provide a concise list.
function filterAndSortList(list, text) {
  var sorted = !text ? list : list.map(function (entry) {
    return {
      proximity: getProximity(normalizeText(entry.text), text),
      entry: entry
    };
  }).filter(function (pair) {
    return pair.proximity <= 2;
  }).sort(function (a, b) {
    return a.proximity - b.proximity || a.entry.text.length - b.entry.text.length;
  }).map(function (pair) {
    return pair.entry;
  });

  return sorted.length > 0 ? sorted : list;
}

function normalizeText(text) {
  return text.toLowerCase().replace(/\W/g, '');
}

// Determine a numeric proximity for a suggestion based on current text.
function getProximity(suggestion, text) {
  // start with lexical distance
  var proximity = lexicalDistance(text, suggestion);
  if (suggestion.length > text.length) {
    // do not penalize long suggestions.
    proximity -= suggestion.length - text.length - 1;
    // penalize suggestions not starting with this phrase
    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;
  }
  return proximity;
}

/**
 * Computes the lexical distance between strings A and B.
 *
 * The "distance" between two strings is given by counting the minimum number
 * of edits needed to transform string A into string B. An edit can be an
 * insertion, deletion, or substitution of a single character, or a swap of two
 * adjacent characters.
 *
 * This distance can be useful for detecting typos in input or sorting
 *
 * @param {string} a
 * @param {string} b
 * @return {int} distance in number of edits
 */
function lexicalDistance(a, b) {
  var i;
  var j;
  var d = [];
  var aLength = a.length;
  var bLength = b.length;

  for (i = 0; i <= aLength; i++) {
    d[i] = [i];
  }

  for (j = 1; j <= bLength; j++) {
    d[0][j] = j;
  }

  for (i = 1; i <= aLength; i++) {
    for (j = 1; j <= bLength; j++) {
      var cost = a[i - 1] === b[j - 1] ? 0 : 1;

      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);

      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
      }
    }
  }

  return d[aLength][bLength];
}